package sync

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode/utf8"
)

// ComposeOverlays reads and composes overlay files in order,
// prepending a managed-content header.
func ComposeOverlays(baseDir string, overlays []string) (*ComposeResult, error) {
	result := &ComposeResult{}
	var parts []string

	for _, overlay := range overlays {
		if err := validateOverlayPath(baseDir, overlay); err != nil {
			return nil, err
		}

		fullPath := filepath.Join(baseDir, overlay)
		data, err := os.ReadFile(fullPath)
		if err != nil {
			if errors.Is(err, os.ErrNotExist) {
				return nil, fmt.Errorf("overlay file not found: %s", overlay)
			}
			return nil, fmt.Errorf("reading overlay %s: %w", overlay, err)
		}

		if !utf8.Valid(data) {
			return nil, fmt.Errorf("overlay %s contains invalid UTF-8 content", overlay)
		}

		content := string(data)
		if len(strings.TrimSpace(content)) == 0 {
			result.Warnings = append(result.Warnings, fmt.Sprintf("overlay %s is empty", overlay))
		}

		parts = append(parts, content)
	}

	header := buildHeader(overlays)
	composed := header + strings.Join(parts, "\n")
	result.Content = []byte(composed)

	return result, nil
}

// validateOverlayPath checks that an overlay path doesn't escape the base directory,
// both lexically and after resolving symlinks.
func validateOverlayPath(baseDir, overlay string) error {
	cleaned := filepath.Clean(overlay)
	absPath := filepath.Join(baseDir, cleaned)

	// Lexical check: ensure the cleaned relative path stays within baseDir
	rel, err := filepath.Rel(baseDir, absPath)
	if err != nil {
		return fmt.Errorf("overlay path traversal rejected: %s", overlay)
	}
	if rel == ".." || strings.HasPrefix(rel, ".."+string(filepath.Separator)) {
		return fmt.Errorf("overlay path traversal rejected: %s", overlay)
	}

	// Symlink check: resolve the actual path and verify it's still under baseDir
	resolvedBase, err := filepath.EvalSymlinks(baseDir)
	if err != nil {
		return fmt.Errorf("resolving base directory: %w", err)
	}
	resolvedPath, err := filepath.EvalSymlinks(absPath)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return nil // file doesn't exist yet; ReadFile will catch this
		}
		return fmt.Errorf("resolving overlay path %s: %w", overlay, err)
	}
	resolvedRel, err := filepath.Rel(resolvedBase, resolvedPath)
	if err != nil || resolvedRel == ".." || strings.HasPrefix(resolvedRel, ".."+string(filepath.Separator)) {
		return fmt.Errorf("overlay path escapes base directory via symlink: %s", overlay)
	}

	return nil
}

// buildHeader creates the managed-content header for the hub file.
func buildHeader(sources []string) string {
	return fmt.Sprintf("<!-- DO NOT EDIT â€” Generated by ailign\n   Source: %s\n   Regenerate: ailign sync\n-->\n\n",
		strings.Join(sources, ", "))
}
