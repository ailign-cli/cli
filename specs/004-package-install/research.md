# Research: Package Manifest & Install

**Feature**: 004-package-install | **Date**: 2026-02-20

## R1: HTTP Client Design

**Decision**: Use `net/http` standard library directly with a thin wrapper struct.

**Rationale**: The CLI only needs GET requests against a REST API. No need for third-party HTTP libraries — `net/http` is sufficient and avoids dependency bloat. The wrapper struct holds base URL, configured `*http.Client` (with timeout), and user-agent string. Domain-specific methods (`GetManifest`, `GetContent`) replace generic HTTP calls.

**Alternatives considered**:
- `go-resty` / `sttp`: Adds dependency for marginal convenience. Rejected — stdlib is adequate for GET-only usage.
- `net/http` without wrapper: Would scatter HTTP config (timeout, headers) across call sites. Rejected — centralizing in a client struct is more maintainable.

## R2: Testability — Registry Client Interface

**Decision**: Define a `RegistryClient` interface at the consumer side (the package that calls the registry), not in the client package. Use `httptest.NewServer` for contract testing with a stub handler.

**Rationale**: Go idiom — interfaces are defined where they're consumed. The stub registry is an `httptest.Server` with handlers that mirror the OpenAPI spec. Tests fail if the CLI sends requests the spec doesn't describe. No external process management, no port conflicts in CI.

**Alternatives considered**:
- Pact / WireMock: Heavyweight for a pre-registry project. Contract artifacts (OpenAPI + fixtures) achieve the same goal without tooling overhead.
- `httptest.NewRecorder`: Tests handlers, not clients. Rejected.

## R3: Error Handling — HTTP to Domain Errors

**Decision**: Map HTTP status codes to sentinel errors at the client boundary.

| HTTP Status | Domain Error | Retry? |
|-------------|-------------|--------|
| 404 | `ErrPackageNotFound` | No |
| 429 | `ErrRateLimited` | Yes (Retry-After) |
| 5xx | `ErrServerError` | Yes (3 attempts, exponential backoff) |
| Network error | `ErrRegistryUnreachable` | Yes |

**Rationale**: Sentinel errors + `errors.Is` at call sites. Typed errors only if structured data (status code, package ref) must travel with the error. For MVP scope, sentinels suffice.

## R4: Content Integrity — SHA-256 Checksums

**Decision**: Compute SHA-256 during download via `io.TeeReader`. Store as SRI format `sha256-<base64>` in the lock file. Verify on every install.

**Rationale**: SRI format is the npm v7+ standard, widely understood. Base64 is more compact than hex. Streaming hash avoids reading content twice. Checksum mismatch is always a hard error — never silent re-fetch (Constitution Principle III: Fail Safe, Not Silent).

**Alternatives considered**:
- Hex encoding: Less standard, longer. Rejected.
- Hash-after-download: Requires buffering entire content in memory. Rejected — `TeeReader` is streaming.

## R5: Atomic File Operations

**Decision**: Write to temp file in same directory as target, then `os.Rename`. Deferred cleanup on failure.

**Rationale**: `os.Rename` is atomic only when source and destination are on the same filesystem. Same-directory temp files guarantee this. Pattern already used by `internal/sync` (hub file writes). On failure, remove temp file before returning error.

## R6: Lock File Design

**Decision**: YAML sequence (not map) sorted by package reference. Schema version field for future evolution.

**Schema**:
```yaml
# ailign-lock.yml — generated by ailign install, do not edit manually
lockfileVersion: 1
packages:
  - reference: "instructions/company/security"
    version: "1.3.0"
    resolved: "https://registry.ailign.dev/v1/packages/instructions/company/security/1.3.0"
    integrity: "sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="
```

**Rationale**: Sequence preserves insertion order in YAML (maps don't guarantee key order). Sort by `reference` ascending before writing for deterministic diffs. `lockfileVersion` enables schema migration without ambiguity. `resolved` field records exact URL fetched (like npm). `fetched` timestamp omitted for MVP — adds governance value but is not required for correctness.

**Workflow**:

| Scenario | Behavior |
|----------|----------|
| No lock file | Fetch all, create lock file |
| Lock exists, versions match | Use locked versions, verify checksums |
| Config version changed | Re-fetch changed package, update lock entry |
| Checksum mismatch | Hard error — never silent re-fetch |

**Alternatives considered**:
- YAML map keyed by reference: Key ordering not guaranteed by `goccy/go-yaml`. Rejected.
- JSON format: Less readable for humans reviewing diffs. Rejected — YAML consistent with `.ailign.yml`.
- Append-only (Go `go.sum` style): Adds complexity without clear benefit for AIlign's scale. Rejected.

## R7: OpenAPI Contract Structure

**Decision**: OpenAPI 3.1 spec at `contracts/registry/openapi.yaml`. Separate JSON schemas referenced via `$ref`. Fixture files in `testdata/registry/`.

**Endpoints**:
```
GET /v1/packages/{type}/{scope}/{name}/versions/{version}  # fetch manifest + content URL
GET /v1/packages/{type}/{scope}/{name}/versions             # list available versions
```

**Rationale**: OpenAPI 3.1 aligns with JSON Schema draft 2020-12 already used by `santhosh-tekuri/jsonschema/v6`. Contract artifacts are self-contained — an independent team could build a compatible registry from these files alone.

**Contract sharing**: When the registry repo is created, it copies `contracts/registry/` and validates conformance in its CI. Start with manual copy (YAGNI), add git submodule if it scales.

## R8: Package Manifest Format

**Decision**: `ailign-pkg.yml` (non-dotfile) with required fields: `name`, `type`, `version`, `description`, `content.main`.

**Schema**:
```yaml
# ailign-pkg.yml
name: "company/security"
type: "instructions"
version: "1.3.0"
description: "Company-wide security instructions for AI coding assistants"
content:
  main: "instructions.md"
```

**Rationale**: Non-dotfile because it's the package's identity (like `package.json`), not a hidden config. `content.main` points to the primary content file — extensible to multi-file packages later. `type` field enables the type-scoped registry path validation (`instructions/company/security` must match `type: instructions`).

## R9: Config Schema Extension

**Decision**: Extend `.ailign.yml` with type-prefixed package references in the existing `packages` field.

**New format**:
```yaml
packages:
  - instructions/company/security@1.3.0
  - instructions/company/typescript@2.1.0
```

**Rationale**: Type prefix makes content type explicit. Breaking change from the current `company/security@1.3.0` format, acceptable pre-v1.0.0 per constitution. The `@` separates name from version — consistent with npm convention.
